{"version":3,"file":"vue.js","sources":["../src/observe/array.js","../src/observe/index.js","../src/utils/index.js","../src/instance/state.js","../src/compiler/html-parser.js","../src/compiler/codegen/index.js","../src/instance/index.js","../src/instance/init.js","../src/compiler/index.js"],"sourcesContent":["// 数组原型，拷贝到arrayProto\nconst arrayProto = Array.prototype\n// 继承原有数组的方法 newArrayProto.__proto__ === arrayProto\nexport let newArrayProto = Object.create(arrayProto)\n// 存放7个会改变原数组变异数组方法\nconst methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']\n\n// 遍历7个变异数组方法，添加到拷贝出来的原型newArrayProto上\nmethodsToPatch.forEach((method) => {\n  newArrayProto[method] = function (...args) {\n    // 访问newArrayProto上的方法实则是访问的数组原型方法\n    let result = arrayProto[method].apply(this, args)\n    // 响应式处理,获取Observe实例\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    // 对新增的进行观测\n    if (inserted) ob.observeArray(inserted)\n    return result\n  }\n})\n","import { newArrayProto } from './array'\nimport { isObject } from '../utils/index'\nexport function observe(data) {\n  if (!isObject(data)) return // data不是对象就不用劫持\n  // data.__ob__ instanceof Observe 为true表示data.__ob__为Observe实例，即已经被观测过了，不需要再观测了\n  if (data.__ob__ instanceof Observe) {\n    return data.__ob__\n  }\n  return new Observe(data)\n}\n\n// 观察者\nclass Observe {\n  constructor(data) {\n    // 将this绑定到data属性__ob__上，方便对新增数组元素进行观测，同时给数据加了标识，表示数据已经被观测过了\n    Object.defineProperty(data, '__ob__', {\n      value: this,\n      enumerable: false\n    })\n    if (Array.isArray(data)) {\n      // data 隐士原型指向重写数组原型对象\n      data.__proto__ = newArrayProto\n      this.observeArray(data)\n    } else {\n      this.walking(data)\n    }\n  }\n  // 迭代对象\n  walking(data) {\n    Object.keys(data).forEach((key) => defineReactive(data, key, data[key])) // 遍历 data 对象属性，依次执行defineReactive方法进行数据劫持\n  }\n  // 迭代数组\n  observeArray(data) {\n    data.forEach((item) => observe(item))\n  }\n}\n/**\n * defineReactive 通过Object.defineProperty api 对数据进行数据劫持\n * @param target 目标数据对象\n * @param key 属性\n * @param value 值\n */\nexport function defineReactive(target, key, value) {\n  observe(value) // 深层次对象递归\n  Object.defineProperty(target, key, {\n    get() {\n      console.log('访问属性' + key)\n      // 访问属性时候执行\n      return value\n    },\n    set(newValue) {\n      console.log('修改属性' + key)\n      // 修改属性值时候执行\n      if (value === newValue) return // 新值和旧值相等就不用赋值\n      observe(newValue) // 新值仍然可能是引用类型，需要继续观测\n      value = newValue // 新值赋值给属性\n    }\n  })\n}\n","/**\n * Query an element selector if it's not an element already.\n */\nexport function query(el) {\n  if (typeof el === 'string') {\n    const selected = document.querySelector(el)\n    if (!selected) {\n      console.warn('Cannot find element: ' + el)\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n// 判断数据是否为对象\nexport function isObject(data) {\n  return !(typeof data !== 'object' && data !== 'null')\n}\n","import { observe } from '../observe/index'\n/**\n * initState 初始化状态，进行data computed watch props等属性的初始化\n * @param vm 实例对象\n */\nexport const initState = function (vm) {\n  const options = vm.$options\n  if (options.data) {\n    initData(vm)\n  }\n  // ...还会有其他属性的初始化操作\n}\n/**\n * initData 初始化数据，对data数据进行监测\n * @param vm 实例对象\n */\nfunction initData(vm) {\n  let data = vm.$options.data\n  data = typeof data === 'function' ? data.apply(vm) : data // 判断data类型，可能是函数也可能是对象\n  vm._data = data\n  observe(data)\n  // 遍历data属性，进行代理处理\n  for (const key in data) {\n    handleProxy(vm, '_data', key)\n  }\n}\n/**\n * handleProxy 处理代理，当我们访问this.name的时候代理，实际访问的是this._data.name\n * @param vm 实例对象\n * @param target _data\n * @param key 属性\n */\nfunction handleProxy(vm, target, key) {\n  Object.defineProperty(vm, key, {\n    get() {\n      return vm[target][key]\n    },\n    set(newValue) {\n      vm[target][key] = newValue\n    }\n  })\n}\n","// 解析标签和属性的正则表达式\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/ //匹配到的是属性，如 a=b,key 是匹配到第一个分组，value 的值可能是 Group 3、Group 4、Group 5 其中的一个，即第三个分组，第四个分组和第五个分组其中一个。\nconst startTagOpen = new RegExp(`^<${qnameCapture}`) // 匹配到的分组是标签开始部分，如：<div\nconst startTagClose = /^\\s*(\\/?)>/ //匹配到的是开始标签的结束部分，如 > 或者 />。\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`) // 匹配到的分组是标签结束部分，如 </div>\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g // 匹配到的是我们表达式的内容，如 {{ name }}\n\nlet stack = [],\n  root,\n  currentParent\nexport function parseHTML(html) {\n  // 创建AST结构元素\n  function createASTElement(tag, attrs) {\n    return {\n      type: 1, // 1表示元素， 3表示普通文本\n      tag,\n      attrsList: attrs,\n      parent: null,\n      children: []\n    }\n  }\n  // 开始标签处理转化ast语法树\n  function start(tag, attrs) {\n    // 生产AST结构的元素\n    let node = createASTElement(tag, attrs)\n    // 没有根节点说明当前元素就是根节点，将当前元素赋值给root\n    if (!root) {\n      root = node\n    }\n    // 如果有父元素，将父元素关联到当前元素的父元素\n    if (currentParent) {\n      node.parent = currentParent\n      // 给父元素的children赋值node\n      currentParent.children.push(node)\n    }\n    // 将元素入栈\n    stack.push(node)\n    // 将当前元素作为父元素\n    currentParent = node\n  }\n  // 结束标签处理转化ast语法树\n  function end(tag) {\n    // 将stack最后一个元素出栈\n    stack.pop()\n    // 将栈中最后一个元素作为父元素\n    currentParent = stack[stack.length - 1]\n  }\n  // 文本处理转化ast语法树\n  function charts(text) {\n    // 文本去空\n    text = text.replace(/\\s/g, '')\n    // 如果是文本就直接放在父元素的children里面\n    text &&\n      currentParent.children.push({\n        type: 3,\n        text,\n        parent: currentParent\n      })\n  }\n  while (html) {\n    let textEnd = html.indexOf('<')\n    // 表示的是标签开始位置或者结束位置\n    if (textEnd === 0) {\n      // 如果是标签开始位置\n      const startTagMatch = parseStartTag()\n      if (startTagMatch) {\n        start(startTagMatch.tagName, startTagMatch.attrs)\n        continue\n      }\n      // 如果是标签结束位置\n      const endTagMatch = html.match(endTag)\n      if (endTagMatch) {\n        end(endTagMatch[1])\n        advance(endTagMatch[0].length)\n        continue\n      }\n    }\n    let text\n    // 表示的是文本结束位置，截取到文本结束位置\n    if (textEnd > 0) {\n      text = html.substring(0, textEnd)\n    }\n    // 表示的是内容全是文本,将内容全部都截取掉\n    if (textEnd < 0) {\n      text = html\n    }\n    if (text) {\n      charts(text)\n      advance(text.length)\n    }\n  }\n  return root\n  // 截取掉被匹配到的模板部分\n  function advance(n) {\n    html = html.substring(n)\n  }\n  function parseStartTag() {\n    // 匹配开始标签\n    const start = html.match(startTagOpen)\n    if (start) {\n      // 定义match 存放标签名和属性\n      const match = {\n        tagName: start[1],\n        attrs: []\n      }\n      // 截取掉匹配到的开始标签部分\n      advance(start[0].length)\n      let end, attr\n      // 匹配属性，只要不是开始标签的结束部分，就一直匹配\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        // 截取掉匹配到的属性部分\n        advance(attr[0].length)\n        // 将属性添加到match下的attrs里\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5]\n        })\n      }\n      // 如果有匹配到开始标签的结束部分，需要截取掉\n      if (end) {\n        advance(end[0].length)\n      }\n      return match\n    }\n    return false\n  }\n}\n","function genProps(props) {\n  let str = ''\n  props.forEach((prop) => {\n    // 单独处理 style 类型\n    if (prop.name === 'style') {\n      let obj = {}\n      prop.value.split(';').forEach((item) => {\n        const [key, val] = item.split(':')\n        obj[key] = val\n      })\n      prop.value = obj\n    }\n    str += `${JSON.stringify(prop.name)}:${JSON.stringify(prop.value)},`\n  })\n  return `{ ${str.slice(0, -1)} }`\n}\nfunction genChildren(children) {\n  if (children) {\n    return children.map((c) => gen(c)).join(',')\n  }\n}\nfunction gen(node) {\n  if (node.type === 1) {\n    return generate(node)\n  } else {\n    return 'xxx'\n  }\n}\nexport const generate = (ast) => {\n  let children = genChildren(ast.children)\n  const code = `_c('${ast.tag}', ${ast.attrsList.length > 0 ? genProps(ast.attrsList) : 'null'}${ast.children.length ? `,${children}` : ''}) `\n  console.log(code)\n}\n","import { initMixin } from './init'\n/**\n * Vue 构造函数\n * @param options 为传入的对象,如:{data:{},computed:{},methods:{}}\n */\nfunction Vue(options) {\n  this._init(options)\n}\ninitMixin(Vue)\n\nexport default Vue\n","import { initState } from './state'\nimport { query } from '../utils/index'\nimport { compileToFunctions } from '../compiler/index'\n// 给Vue原型添加_init方法\nexport const initMixin = (Vue) => {\n  Vue.prototype._init = function (options) {\n    const vm = this\n    // 将options挂载在实例上，以$开头，和$set、$nextTick一样的命名规则\n    vm.$options = options\n    // 初始化状态\n    initState(vm)\n\n    // 判断传入的options是否有根元素\n    if (vm.$options.el) {\n      // 执行挂载元素方法\n      vm.$mount(vm.$options.el)\n    }\n  }\n\n  Vue.prototype.$mount = function (el) {\n    // 获取元素\n    el = el && query(el)\n    const options = this.$options\n    // 判断元素是否直接挂载到body上\n    if (el === document.body || el === document.documentElement) {\n      console.warn(`Do not mount Vue to <html> or <body> - mount to normal elements instead.`)\n      return this\n    }\n    // 优先级 render > template > el\n    // 没有render函数\n    if (!options.render) {\n      let template\n      // 有template属性，采用template\n      if (options.template) {\n        template = options.template\n      } else if (el) {\n        // 没有template属性，采用el.outerHTML\n        template = el.outerHTML\n      }\n      if (template) {\n        options.render = compileToFunctions(template)\n      }\n    }\n  }\n}\n","import { parseHTML } from './html-parser'\nimport { generate } from './codegen/index'\nexport const compileToFunctions = (template) => {\n  const ast = parseHTML(template)\n  generate(ast)\n}\n"],"names":["arrayProto","Array","prototype","let","newArrayProto","Object","create","observe","data","__ob__","Observe","forEach","method","args","result","apply","this","ob","inserted","slice","observeArray","constructor","defineProperty","value","enumerable","isArray","__proto__","walking","keys","key","target","get","console","log","set","newValue","item","initState","vm","$options","initData","_data","handleProxy","ncname","qnameCapture","attribute","startTagOpen","RegExp","startTagClose","endTag","stack","root","currentParent","parseHTML","html","textEnd","indexOf","startTagMatch","start","match","tagName","attrs","advance","length","end","attr","push","name","tag","node","type","attrsList","parent","children","endTagMatch","pop","text","substring","replace","n","genChildren","map","c","gen","generate","join","ast","code","props","str","prop","obj","split","val","JSON","stringify","Vue","options","_init","el","$mount","document","querySelector","warn","createElement","body","documentElement","render","template","outerHTML"],"mappings":"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"}