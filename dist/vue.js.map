{"version":3,"file":"vue.js","sources":["../src/observe/array.js","../src/observe/index.js","../src/utils/index.js","../src/instance/state.js","../src/compiler/index.js","../src/instance/index.js","../src/instance/init.js"],"sourcesContent":["// 数组原型，拷贝到arrayProto\nconst arrayProto = Array.prototype\n// 继承原有数组的方法 newArrayProto.__proto__ === arrayProto\nexport let newArrayProto = Object.create(arrayProto)\n// 存放7个会改变原数组变异数组方法\nconst methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']\n\n// 遍历7个变异数组方法，添加到拷贝出来的原型newArrayProto上\nmethodsToPatch.forEach((method) => {\n  newArrayProto[method] = function (...args) {\n    // 访问newArrayProto上的方法实则是访问的数组原型方法\n    let result = arrayProto[method].apply(this, args)\n    // 响应式处理,获取Observe实例\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    // 对新增的进行观测\n    if (inserted) ob.observeArray(inserted)\n    return result\n  }\n})\n","import { newArrayProto } from './array'\nimport { isObject } from '../utils/index'\nexport function observe(data) {\n  if (!isObject(data)) return // data不是对象就不用劫持\n  // data.__ob__ instanceof Observe 为true表示data.__ob__为Observe实例，即已经被观测过了，不需要再观测了\n  if (data.__ob__ instanceof Observe) {\n    return data.__ob__\n  }\n  return new Observe(data)\n}\n\n// 观察者\nclass Observe {\n  constructor(data) {\n    // 将this绑定到data属性__ob__上，方便对新增数组元素进行观测，同时给数据加了标识，表示数据已经被观测过了\n    Object.defineProperty(data, '__ob__', {\n      value: this,\n      enumerable: false\n    })\n    if (Array.isArray(data)) {\n      // data 隐士原型指向重写数组原型对象\n      data.__proto__ = newArrayProto\n      this.observeArray(data)\n    } else {\n      this.walking(data)\n    }\n  }\n  // 迭代对象\n  walking(data) {\n    Object.keys(data).forEach((key) => defineReactive(data, key, data[key])) // 遍历 data 对象属性，依次执行defineReactive方法进行数据劫持\n  }\n  // 迭代数组\n  observeArray(data) {\n    data.forEach((item) => observe(item))\n  }\n}\n/**\n * defineReactive 通过Object.defineProperty api 对数据进行数据劫持\n * @param target 目标数据对象\n * @param key 属性\n * @param value 值\n */\nexport function defineReactive(target, key, value) {\n  observe(value) // 深层次对象递归\n  Object.defineProperty(target, key, {\n    get() {\n      console.log('访问属性' + key)\n      // 访问属性时候执行\n      return value\n    },\n    set(newValue) {\n      console.log('修改属性' + key)\n      // 修改属性值时候执行\n      if (value === newValue) return // 新值和旧值相等就不用赋值\n      observe(newValue) // 新值仍然可能是引用类型，需要继续观测\n      value = newValue // 新值赋值给属性\n    }\n  })\n}\n","/**\n * Query an element selector if it's not an element already.\n */\nexport function query(el) {\n  if (typeof el === 'string') {\n    const selected = document.querySelector(el)\n    if (!selected) {\n      console.warn('Cannot find element: ' + el)\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n// 判断数据是否为对象\nexport function isObject(data) {\n  return !(typeof data !== 'object' && data !== 'null')\n}\n","import { observe } from '../observe/index'\n/**\n * initState 初始化状态，进行data computed watch props等属性的初始化\n * @param vm 实例对象\n */\nexport const initState = function (vm) {\n  const options = vm.$options\n  if (options.data) {\n    initData(vm)\n  }\n  // ...还会有其他属性的初始化操作\n}\n/**\n * initData 初始化数据，对data数据进行监测\n * @param vm 实例对象\n */\nfunction initData(vm) {\n  let data = vm.$options.data\n  data = typeof data === 'function' ? data.apply(vm) : data // 判断data类型，可能是函数也可能是对象\n  vm._data = data\n  observe(data)\n  // 遍历data属性，进行代理处理\n  for (const key in data) {\n    handleProxy(vm, '_data', key)\n  }\n}\n/**\n * handleProxy 处理代理，当我们访问this.name的时候代理，实际访问的是this._data.name\n * @param vm 实例对象\n * @param target _data\n * @param key 属性\n */\nfunction handleProxy(vm, target, key) {\n  Object.defineProperty(vm, key, {\n    get() {\n      return vm[target][key]\n    },\n    set(newValue) {\n      vm[target][key] = newValue\n    }\n  })\n}\n","// 解析标签和属性的正则表达式\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/ //匹配到的是属性，如 a=b,key 是匹配到第一个分组，value 的值可能是 Group 3、Group 4、Group 5 其中的一个，即第三个分组，第四个分组和第五个分组其中一个。\nconst startTagOpen = new RegExp(`^<${qnameCapture}`) // 匹配到的分组是标签开始部分，如：<div\nconst startTagClose = /^\\s*(\\/?)>/ //匹配到的是开始标签的结束部分，如 > 或者 />。\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`) // 匹配到的分组是标签结束部分，如 </div>\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g // 匹配到的是我们表达式的内容，如 {{ name }}\n\nexport const compileToFunctions = (template) => {\n  const ast = parseHTML(template)\n}\n\nlet stack = [],\n  root,\n  currentParent\nfunction parseHTML(html) {\n  // 创建AST结构元素\n  function createASTElement(tag, attrs) {\n    return {\n      type: 1, // 1表示元素， 3表示普通文本\n      tag,\n      attrsList: attrs,\n      parent: null,\n      children: []\n    }\n  }\n  // 开始标签处理转化ast语法树\n  function start(tag, attrs) {\n    // 生产AST结构的元素\n    let node = createASTElement(tag, attrs)\n    // 没有根节点说明当前元素就是根节点，将当前元素赋值给root\n    if (!root) {\n      root = node\n    }\n    // 如果有父元素，将父元素关联到当前元素的父元素\n    if (currentParent) {\n      node.parent = currentParent\n      // 给父元素的children赋值node\n      currentParent.children.push(node)\n    }\n    // 将元素入栈\n    stack.push(node)\n    // 将当前元素作为父元素\n    currentParent = node\n  }\n  // 结束标签处理转化ast语法树\n  function end(tag) {\n    // 将stack最后一个元素出栈\n    stack.pop()\n    // 将栈中最后一个元素作为父元素\n    currentParent = stack[stack.length - 1]\n  }\n  // 文本处理转化ast语法树\n  function charts(text) {\n    // 文本去空\n    text = text.replace(/\\s/g, '')\n    // 如果是文本就直接放在父元素的children里面\n    text &&\n      currentParent.children.push({\n        type: 3,\n        text,\n        parent: currentParent\n      })\n  }\n  while (html) {\n    let textEnd = html.indexOf('<')\n    // 表示的是标签开始位置或者结束位置\n    if (textEnd === 0) {\n      // 如果是标签开始位置\n      const startTagMatch = parseStartTag()\n      if (startTagMatch) {\n        start(startTagMatch.tagName, startTagMatch.attrs)\n        continue\n      }\n      // 如果是标签结束位置\n      const endTagMatch = html.match(endTag)\n      if (endTagMatch) {\n        end(endTagMatch[1])\n        advance(endTagMatch[0].length)\n        continue\n      }\n    }\n    let text\n    // 表示的是文本结束位置，截取到文本结束位置\n    if (textEnd > 0) {\n      text = html.substring(0, textEnd)\n    }\n    // 表示的是内容全是文本,将内容全部都截取掉\n    if (textEnd < 0) {\n      text = html\n    }\n    if (text) {\n      charts(text)\n      advance(text.length)\n    }\n  }\n  console.log(root)\n  // 截取掉被匹配到的模板部分\n  function advance(n) {\n    html = html.substring(n)\n  }\n  function parseStartTag() {\n    // 匹配开始标签\n    const start = html.match(startTagOpen)\n    if (start) {\n      // 定义match 存放标签名和属性\n      const match = {\n        tagName: start[1],\n        attrs: []\n      }\n      // 截取掉匹配到的开始标签部分\n      advance(start[0].length)\n      let end, attr\n      // 匹配属性，只要不是开始标签的结束部分，就一直匹配\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        // 截取掉匹配到的属性部分\n        advance(attr[0].length)\n        // 将属性添加到match下的attrs里\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5]\n        })\n      }\n      // 如果有匹配到开始标签的结束部分，需要截取掉\n      if (end) {\n        advance(end[0].length)\n      }\n      return match\n    }\n    return false\n  }\n}\n","import { initMixin } from './init'\n/**\n * Vue 构造函数\n * @param options 为传入的对象,如:{data:{},computed:{},methods:{}}\n */\nfunction Vue(options) {\n  this._init(options)\n}\ninitMixin(Vue)\n\nexport default Vue\n","import { initState } from './state'\nimport { query } from '../utils/index'\nimport { compileToFunctions } from '../compiler/index'\n// 给Vue原型添加_init方法\nexport const initMixin = (Vue) => {\n  Vue.prototype._init = function (options) {\n    const vm = this\n    // 将options挂载在实例上，以$开头，和$set、$nextTick一样的命名规则\n    vm.$options = options\n    // 初始化状态\n    initState(vm)\n\n    // 判断传入的options是否有根元素\n    if (vm.$options.el) {\n      // 执行挂载元素方法\n      vm.$mount(vm.$options.el)\n    }\n  }\n\n  Vue.prototype.$mount = function (el) {\n    // 获取元素\n    el = el && query(el)\n    const options = this.$options\n    // 判断元素是否直接挂载到body上\n    if (el === document.body || el === document.documentElement) {\n      console.warn(`Do not mount Vue to <html> or <body> - mount to normal elements instead.`)\n      return this\n    }\n    // 没有render函数\n    if (!options.render) {\n      let template\n      // 有template属性，采用template\n      if (options.template) {\n        template = options.template\n      } else if (el) {\n        // 没有template属性，采用el.outerHTML\n        template = el.outerHTML\n      }\n      if (template) {\n        options.render = compileToFunctions(template)\n      }\n    }\n  }\n}\n"],"names":["arrayProto","Array","prototype","let","newArrayProto","Object","create","observe","data","__ob__","Observe","forEach","method","args","result","apply","this","ob","inserted","slice","observeArray","constructor","defineProperty","value","enumerable","isArray","__proto__","walking","keys","key","target","get","console","log","set","newValue","item","initState","vm","$options","initData","_data","handleProxy","ncname","qnameCapture","attribute","startTagOpen","RegExp","startTagClose","endTag","compileToFunctions","template","parseHTML","html","textEnd","indexOf","startTagMatch","start","match","tagName","attrs","advance","length","end","attr","push","name","tag","node","type","attrsList","parent","children","root","currentParent","stack","endTagMatch","pop","text","substring","charts","replace","n","Vue","options","_init","el","$mount","document","querySelector","warn","createElement","body","documentElement","render","outerHTML"],"mappings":"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"}