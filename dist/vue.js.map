{"version":3,"file":"vue.js","sources":["../src/observe/array.js","../src/observe/index.js","../src/state.js","../src/index.js","../src/init.js"],"sourcesContent":["// 数组原型，拷贝到arrayProto\nconst arrayProto = Array.prototype\n// 继承原有数组的方法 newArrayProto.__proto__ === arrayProto\nexport let newArrayProto = Object.create(arrayProto)\n// 存放7个会改变原数组变异数组方法\nconst methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']\n\n// 遍历7个变异数组方法，添加到拷贝出来的原型newArrayProto上\nmethodsToPatch.forEach((method) => {\n  newArrayProto[method] = function (...args) {\n    // 访问newArrayProto上的方法实则是访问的数组原型方法\n    let result = arrayProto[method].apply(this, args)\n    // 响应式处理,获取Observe实例\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    // 对新增的进行观测\n    if (inserted) ob.observeArray(inserted)\n    return result\n  }\n})\n","import { newArrayProto } from './array'\nexport function observe(data) {\n  if (typeof data !== 'object' && data !== 'null') return // data不是对象就不用劫持\n  // data.__ob__ instanceof Observe 为true表示data.__ob__为Observe实例，即已经被观测过了，不需要再观测了\n  if (data.__ob__ instanceof Observe) {\n    return data.__ob__\n  }\n  return new Observe(data)\n}\n\n// 观察者\nclass Observe {\n  constructor(data) {\n    // 将this绑定到data属性__ob__上，方便对新增数组元素进行观测，同时给数据加了标识，表示数据已经被观测过了\n    Object.defineProperty(data, '__ob__', {\n      value: this,\n      enumerable: false\n    })\n    if (Array.isArray(data)) {\n      // data 隐士原型指向重写数组原型对象\n      data.__proto__ = newArrayProto\n      this.observeArray(data)\n    } else {\n      this.walking(data)\n    }\n  }\n  // 迭代对象\n  walking(data) {\n    Object.keys(data).forEach((key) => defineReactive(data, key, data[key])) // 遍历 data 对象属性，依次执行defineReactive方法进行数据劫持\n  }\n  // 迭代数组\n  observeArray(data) {\n    data.forEach((item) => observe(item))\n  }\n}\n/**\n * defineReactive 通过Object.defineProperty api 对数据进行数据劫持\n * @param target 目标数据对象\n * @param key 属性\n * @param value 值\n */\nexport function defineReactive(target, key, value) {\n  observe(value) // 深层次对象递归\n  Object.defineProperty(target, key, {\n    get() {\n      console.log('访问属性' + key)\n      // 访问属性时候执行\n      return value\n    },\n    set(newValue) {\n      console.log('修改属性' + key)\n      // 修改属性值时候执行\n      if (value === newValue) return // 新值和旧值相等就不用赋值\n      observe(newValue) // 新值仍然可能是引用类型，需要继续观测\n      value = newValue // 新值赋值给属性\n    }\n  })\n}\n","import { observe } from './observe/index'\n/**\n * initState 初始化状态，进行data computed watch props等属性的初始化\n * @param vm 实例对象\n */\nexport const initState = function (vm) {\n  const options = vm.$options\n  if (options.data) {\n    initData(vm)\n  }\n  // ...还会有其他属性的初始化操作\n}\n/**\n * initData 初始化数据，对data数据进行监测\n * @param vm 实例对象\n */\nfunction initData(vm) {\n  let data = vm.$options.data\n  data = typeof data === 'function' ? data.apply(vm) : data // 判断data类型，可能是函数也可能是对象\n  vm._data = data\n  observe(data)\n  // 遍历data属性，进行代理处理\n  for (const key in data) {\n    handleProxy(vm, '_data', key)\n  }\n}\n/**\n * handleProxy 处理代理，当我们访问this.name的时候代理，实际访问的是this._data.name\n * @param vm 实例对象\n * @param target _data\n * @param key 属性\n */\nfunction handleProxy(vm, target, key) {\n  Object.defineProperty(vm, key, {\n    get() {\n      return vm[target][key]\n    },\n    set(newValue) {\n      vm[target][key] = newValue\n    }\n  })\n}\n","import { initMixin } from './init'\n/**\n * Vue 构造函数\n * @param options 为传入的对象,如:{data:{},computed:{},methods:{}}\n */\nfunction Vue(options) {\n  this._init(options)\n}\ninitMixin(Vue)\n\nexport default Vue\n","import { initState } from './state'\n// 给Vue原型添加_init方法\nexport const initMixin = (Vue) => {\n  Vue.prototype._init = function (options) {\n    const vm = this\n    vm.$options = options // 将options挂载在实例上，以$开头，和$set、$nextTick一样的命名规则\n    initState(vm) // 初始化状态\n  }\n}\n"],"names":["arrayProto","Array","prototype","let","newArrayProto","Object","create","observe","data","__ob__","Observe","forEach","method","args","result","apply","this","ob","inserted","slice","observeArray","constructor","defineProperty","value","enumerable","isArray","__proto__","walking","keys","key","target","get","console","log","set","newValue","item","initState","vm","$options","initData","_data","handleProxy","Vue","options","_init"],"mappings":"wfACA,MAAMA,EAAaC,MAAMC,UAElBC,IAAIC,EAAgBC,OAAOC,OAAON,CAAU,ECF5C,SAASO,EAAQC,GACtB,GAAoB,UAAhB,OAAOA,GAA8B,SAATA,EAEhC,OAAIA,EAAKC,kBAAkBC,EAClBF,EAAKC,OAEP,IAAIC,EAAQF,CAAI,CACzB,CDHuB,CAAC,OAAQ,MAAO,QAAS,UAAW,SAAU,OAAQ,WAG9DG,QAASC,IACtBR,EAAcQ,GAAU,YAAaC,GAEnCV,IAAIW,EAASd,EAAWY,GAAQG,MAAMC,KAAMH,CAAI,EAE1CI,EAAKD,KAAKP,OAChBN,IAAIe,EACJ,OAAQN,GACN,IAAK,OACL,IAAK,UACHM,EAAWL,EACX,MACF,IAAK,SACHK,EAAWL,EAAKM,MAAM,CAAC,CAClB,CAIT,OADID,GAAUD,EAAGG,aAAaF,CAAQ,EAC/BJ,EAEX,CAAC,QCjBKJ,EACJW,YAAYb,GAEVH,OAAOiB,eAAed,EAAM,SAAU,CACpCe,MAAOP,KACPQ,WAAY,CAAA,CACd,CAAC,EACGvB,MAAMwB,QAAQjB,CAAI,GAEpBA,EAAKkB,UAAYtB,EACjBY,KAAKI,aAAaZ,CAAI,GAEtBQ,KAAKW,QAAQnB,CAAI,CAErB,CAEAmB,QAAQnB,GACNH,OAAOuB,KAAKpB,CAAI,EAAEG,QAASkB,IAaxB,IAAwBC,EAAQD,EAAKN,EAC1ChB,EAD0CgB,GAAbO,EAbuBtB,GAafqB,EAbqBA,EAc7C,EACbxB,OAAOiB,eAAeQ,EAAQD,EAAK,CACjCE,MAGE,OAFAC,QAAQC,IAAI,OAASJ,CAAG,EAEjBN,CACR,EACDW,IAAIC,GACFH,QAAQC,IAAI,OAASJ,CAAG,EAEpBN,IAAUY,IACd5B,EAAQ4B,CAAQ,EAChBZ,EAAQY,EACV,CACF,CAAC,CA5BuE,CAAC,CACzE,CAEAf,aAAaZ,GACXA,EAAKG,QAASyB,GAAS7B,EAAQ6B,CAAI,CAAC,CACtC,CACF,CC7ByB,SAAZC,EAAsBC,GAEjC,GADgBA,EAAGC,SACP/B,KACVgC,CAAAA,IAQcF,EARLA,EASXnC,IAAIK,EAAO8B,EAAGC,SAAS/B,KACvBA,EAAuB,YAAhB,OAAOA,EAAsBA,EAAKO,MAAMuB,CAAE,EAAI9B,EAErDD,EADA+B,EAAGG,MAAQjC,CACC,EAEZ,IAAK,MAAMqB,KAAOrB,EAChBkC,CASJ,SAAqBJ,EAAIR,EAAQD,GAC/BxB,OAAOiB,eAAegB,EAAIT,EAAK,CAC7BE,MACE,OAAOO,EAAGR,GAAQD,EACnB,EACDK,IAAIC,GACFG,EAAGR,GAAQD,GAAOM,CACpB,CACF,CAAC,CACH,EAlBgBG,EAAI,QAAST,CAAG,CAfjB,CAGf,CCNA,SAASc,EAAIC,GACX5B,KAAK6B,MAAMD,CAAO,CACpB,QACUD,ECLJzC,UAAU2C,MAAQ,SAAUD,GACnB5B,KACRuB,SAAWK,EACdP,EAFWrB,IAEC"}